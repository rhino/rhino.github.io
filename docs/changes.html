<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en"><html><head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="Author" content="Norris Boyd">
   <meta name="GENERATOR" content="Mozilla/4.75 [en] (Windows NT 5.0; U) [Netscape]">
   <meta name="KeyWords" content="Rhino, JavaScript, Java"><title>Change Log</title></head>

<body bgcolor="#ffffff">

<h1 align="center">
Change Log for Significant Rhino Changes</h1>

This is a log of significant changes since the release of Rhino 1.5 Release 3.

<h3>Rhino debug API changes</h3>

A new, incompatible Rhino debug API gives an option to monitor
entering/leaving of script functions while decreasing the amount of code to
implement the API in the Rhino core.
<p>
The main difference between the old and new API is that the application needs to implement both org.mozilla.javascript.debugger.Debugger and
org.mozilla.javascript.debugger.DebugFrame interfaces to receive debug
information during script execution. See the API documentation for these
classes for details:
<br>
<tt><a href="http://lxr.mozilla.org/mozilla/source/js/rhino/src/org/mozilla/javascript/debug/DebugFrame.java">http://lxr.mozilla.org/mozilla/source/js/rhino/src/org/mozilla/javascript/debug/DebugFrame.java</a>
<br><a href="http://lxr.mozilla.org/mozilla/source/js/rhino/src/org/mozilla/javascript/debug/Debugger.java">http://lxr.mozilla.org/mozilla/source/js/rhino/src/org/mozilla/javascript/debug/Debugger.java</a>
</tt>
<p>
In addition the org.mozilla.javascript.debugger.DebuggableEngine interface and the getDebuggableEngine method in org.mozilla.javascript.Context are replaced by 3 Context methods: setDebugger, getDebugger and getDebuggerContextData to set/get debugger and its Context data in the current thread Context:<br>
<tt><a href="http://lxr.mozilla.org/mozilla/source/js/rhino/src/org/mozilla/javascript/Context.java">http://lxr.mozilla.org/mozilla/source/js/rhino/src/org/mozilla/javascript/Context.java</a></tt>

<p>The following gives few examples how to update your current application to  the new API.
<p>
1. Setting and querying a Debugger implementation
<p>
Old API:
<pre>
cx.getDebuggableEngine.setDebugger(debugger);
cx.getDebuggableEngine.getDebugger();
</pre>
New API:
<pre>
cx.setDebugger(debugger);
cx.getDebugger();
</pre>

<p>
2. Monitoring execution of each line in the script
<p>
Old implementation:
<pre>
public MyDebugger implement Debugger {

    public void handleCompilationDone(Context cx, 
                                      DebuggableScript fnOrScript,
                                      StringBuffer source)
    {
    }

    void handleBreakpointHit(Context cx) 
    {
        DebugFrame frame = cx.getDebuggableEngine().getFrame(0);
        System.out.println("New line:" + frame.getLineNumber());
    }

    void handleExceptionThrown(Context cx, Object exception)
    {
    }
}
...
cx.getDebuggableEngine.setDebugger(new MyDebugger());
cx.getDebuggableEngine.setBreakNextLine(true);
</pre>

New implementation:
<pre>
public MyDebugger implement Debugger 
{
    public void handleCompilationDone(Context cx,
                                      DebuggableScript fnOrScript,
                                      StringBuffer source)
    {
    }
    
    public DebugFrame getFrame(Context cx, DebuggableScript fnOrScript)
    {
        return new MyDebugFrame();
    }
}

class MyDebugFrame implements DebugFrame
{
    public void onEnter(Context cx, Scriptable activation,
                        Scriptable thisObj, Object[] args)
    {
    }
    
    public void onExceptionThrown(Context cx, Throwable ex)
    {
    }
    
    public void onExit(Context cx, boolean byThrow,
                       Object resultOrException)
    {
    }

    public void onLineChange(Context cx, int lineNumber) 
    {
        System.out.println("New line:" + frame.getLineNumber());
    }
}
...
cx.setDebugger(new MyDebugger());
</pre>
Note the in the new implementation the application can monitor function  enter/exit by customizing enterFrame and onExit in the above code.
<p>
3. Breakpoint handling
<p>
Old implementation:
<pre>
public MyDebugger implement Debugger {

    public void handleCompilationDone(Context cx, DebuggableScript fnOrScript,
                                      StringBuffer source)
    {
        int breakpointLine = ...;
        fnOrScript.placeBreakpoint(breakpointLine);
    }

    void handleBreakpointHit(Context cx) {
        DebugFrame frame = cx.getDebuggableEngine().getFrame(0);
        System.out.println("Breakpoint hit: "+frame.getSourceName()+":"+frame.getLineNumber());
    }

    void handleExceptionThrown(Context cx, Object exception)
    {
    }
}
...
cx.getDebuggableEngine.setDebugger(new MyDebugger());
</pre>

New implementation:
<pre>
public MyDebugger implement Debugger 
{
    public void handleCompilationDone(Context cx,
                                      DebuggableScript fnOrScript,
                                      StringBuffer source)
    {
    }
    
    public DebugFrame getFrame(Context cx, DebuggableScript fnOrScript)
    {
        return new MyDebugFrame(fnOrScript);
    }
}

class MyDebugFrame implements DebugFrame
{
    DebuggableScript fnOrScript;
    
    MyDebugFrame(DebuggableScript fnOrScript)
    {
        this.fnOrScript = fnOrScript;
    }
    
    public void onEnter(Context cx, Scriptable activation,
                        Scriptable thisObj, Object[] args)
    {
	System.out.println("Frame entered");
    }
    
    public void onLineChange(Context cx, int lineNumber) 
    {
        if (isBreakpoint(lineNumber)) {
            System.out.println("Breakpoint hit: "+fnOrScript.getSourceName()+":"+lineNumber);
        }
    }
    
    public void onExceptionThrown(Context cx, Throwable ex)
    {
    }
    
    public void onExit(Context cx, boolean byThrow,
                       Object resultOrException)
    {
        System.out.println("Frame exit, result="+resultOrException);
    }
    
    private boolean isBreakpoint(int lineNumber) 
    {
    	...
    } 
}
...
cx.setDebugger(new MyDebugger());
</pre>

Here debugger during execution needs to decide if a particular line has breakpoint on it set or not during script execution, not at the moment of script initialization.

<p>See also Rhino Debugger that fully explore the new API:<br><tt><a  href="http://lxr.mozilla.org/mozilla/source/js/rhino/toolsrc/org/mozilla/javascript/tools/debugger/Main.java">http://lxr.mozilla.org/mozilla/source/js/rhino/toolsrc/org/mozilla/javascript/tools/debugger/Main.java</a></tt>. The debugger changes includes support for debugging eval and Function scripts and loading script sources from their URL if debugger was not installed during scripts initialization.

<h3>WrapFactory introduced, WrapHandler deprecated</h3>
A design flaw in the WrapHandler interface (a call to a Java contructor from
JavaScript would result in a call to wrap the result, which would then be
cast to a Scriptable) inspired the deprecation of that interface and the
introduction of a new class, WrapFactory, that contains a new method called
on the result of a constructor call and can be customized by application if necessary.
<p>
In addition, WrapFactory has the new <tt>setJavaPrimitiveWrap</tt> method to control if instances of Java <tt>String</tt> and <tt>Number</tt> class should be wrapped to special script objects as any other Java objects so a script can access any method <tt>String</tt> and <tt>Number</tt>, or they should be converted to JavaScript primitive strings and numbers.

<h3>New security interfaces</h3>
<p>
SecuritySupport is replaced by ClassShutter and SecurityController, where ClassShutter controls which classes are visible to scripts via LiveConnect and 
SecurityController provides permission management. For compatibility SecuritySupport is still available as a deprecated interface but only its visibleToScripts method is used as an alias for ClassShutter.visibleToScripts. See API documentation for new classes for details.
<p>
New SecurityController allows integration of script security with Java2 security model and its implementation that uses java policy settings to restrict script permissions based on its URL is available with Rhino shell. See the <a href="http://lxr.mozilla.org/mozilla/source/js/rhino/toolsrc/org/mozilla/javascript/tools/shell/JavaPolicySecurity.java">JavaPolicySecurity</a> source for details. To activate it, set the <tt>rhino.use_java_policy_security</tt> system property to true when invoking Rhino shell together with installing a security manager.


<h3>Regular expressions improvements</h3>
<a href="mailto:rogerl@netscape.com">rogerl@netscape.com</a> committed new regular expressions implementation which fully confirms to EcmaScript 262 standard and faster.

<hr width="100%"><br>
<a href="index.html">back to top</a></h3>


</body></html>
