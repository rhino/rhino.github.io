<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html><head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="Author" content="Igor Bukanov">
  <meta name="KeyWords" content="Rhino, JavaScript, Java">
  <title>Change Log</title>
</head>

<body bgcolor="#ffffff">

<h1 align="center">
Rhino 1.5R5 Change Log</h1>

This is a log of significant changes in Rhino 1.5 Release 5.

<h3>Wrapping of JavaScript functions as Java interfaces</h3>
<p>
Rhino allows to pass a JavaScript function to a Java method expecting an interface with a single method. The JavaScript function will be called whenever the interface's method is called from Java. It allows to simplify code that previously had to create explicit JavaAdapter objects. 
</p>
<p>
For example, one can write now:
<pre>
    var button = new javax.swing.JButton("My Button");
    button.addActionListener(function(e) {
    	java.lang.System.out.println("Button click:"+e);
    }); 
</pre>
instead of 
<pre>
    var button = new javax.swing.JButton("My Button");
    button.addActionListener(new java.awt.event.ActionListener({
    	actionPerformed : function(e) {
    	    java.lang.System.out.println("Button click:"+e);
    	}
    });
</pre>
which was necessary in the previous version of Rhino. 
See <a href="http://bugzilla.mozilla.org/show_bug.cgi?id=223435">Bugzilla 223435</a>.
</p>

<h3>uneval() and toSource()</h3>
<p>
Rhino fully supports <tt>uneval()</tt> function and <tt>toSource()</tt> method which are extensions to ECMAScript available in <a href="http://www.mozilla.org/js/">SpiderMonkey</a>. They return a string that can be passed to the <tt>eval()</tt> function to reconstruct the original value when possible. It is guaranteed that <tt>uneval(eval(uneval(x)))&nbsp;==&nbsp;uneval(x)</tt> and in many cases more useful notion <tt>eval(uneval(x))&nbsp;==&nbsp;deep_copy_of_x</tt> holds. 
</p>
<p> 
For example, here is an extract from a <a href="shell.html">Rhino shell</a> session: 
</p>
<pre>
js&gt; var x = { a: 1, b: 2, c: [1,2,3,4,5], f: function test() { return 1; }, o: { property1: "Test", proeprty2: new Date()}}
js&gt; uneval(x)
({c:[1, 2, 3, 4, 5], o:{property1:"Test", proeprty2:(new Date(1076585338601))}, f:(function test() {return 1;}), a:1, b:2})
js&gt; x.toSource()
({c:[1, 2, 3, 4, 5], o:{property1:"Test", proeprty2:(new Date(1076585338601))}, f:(function test() {return 1;}), a:1, b:2})
js&gt; uneval(x.propertyThatDoesNotExist)
undefined
</pre>
<p>
See <a href="http://bugzilla.mozilla.org/show_bug.cgi?id=225465">Bugzilla 225465</a>.
</p>

<h3>seal() and changes in semantic of sealed objects</h3>
<p>
Rhino supports <tt>seal(object)</tt> function which is another ECMAScript extension from SpiderMonkey. The function makes object immune to changes and any attempt to add, modify or delete a property of such object will throw an exception. Previously sealing was only possible through Java method <tt>sealObject()</tt> method in <tt>org.mozilla.javascript.ScriptableObject</tt> and before Rhino 1.5R5 it was possible to modify existing properties of sealed objects. 
</p>
<p>
See <a href="http://bugzilla.mozilla.org/show_bug.cgi?id=203013">Bugzilla 203013</a>.
</p>
 
<h3>Exception changes</h3>
<p>
In Rhino 1.5R5 all exceptions generated during execution of a script provide information about script's source name and line number that triggered the exception. The exception class <tt>org.mozilla.javascript.JavaScriptException</tt> is used now only to represent exceptions explicitly thrown by the JavaScript <b>throw</b> statement, it never wraps exceptions thrown in a Java method invoked by the script. Such exceptions are always wrapped as  <tt>org.mozilla.javascript.WrappedException</tt>.
</p>
<p>
 See <a  href="http://bugzilla.mozilla.org/show_bug.cgi?id=217584">Bugzilla 217584</a>, <a href="http://bugzilla.mozilla.org/show_bug.cgi?id=219055">Bugzilla 219055</a>
and <a href="http://bugzilla.mozilla.org/show_bug.cgi?id=225817">Bugzilla 225817</a>
</p>

<h3>Compiled scripts are scope independent</h3>
<p>
Previously Rhino required a scope object in the <tt>compileReader</tt> method of <tt>org.mozilla.javascript.Context</tt> to compile a script into <tt>org.mozilla.javascript.Script</tt> instances. Under some circumstances it was possible that the scope object would be stored in the compiled form of the script. It made impossible in such cases to reuse of the compiled form to execute the script against different scopes and lead to potential memory leaks.
<p>
</p>Rhino 1.5R5 fixes such misbehavior and <tt>compileReader</tt> and newly introduced <tt>compileString</tt> no longer take the scope argument. For compatibility the old form of <tt>compileReader</tt> is kept as a deprecated method. 
</p>
<p>
See <a href="http://bugzilla.mozilla.org/show_bug.cgi?id=218440">Bugzilla 218440</a>.
</p>

<h3>Callable interface</h3>
<p>
All <tt>org.mozilla.javascript.Script</tt> and <tt>org.mozilla.javascript.Function</tt> instances in Rhino now implements the new interface <tt>org.mozilla.javascript.Callable</tt> which together with the new <tt>call</tt> method in <tt>org.mozilla.javascript.Context</tt> gives a simple way to call scripts and functions without explicit calls to <tt>Context.enter()</tt> and <tt>Context.exit()</tt>. 
</p>
<p>
The <tt>Callable</tt> interface also allows to set the value of JavaScript <b>this</b> during script execution to arbitrary <tt>org.mozilla.javascript.Scriptable</tt> instance overriding default bahaviour of using the scope object for the value of <b>this</b>.  
</p>


<h3>No static caching</h3>
<p>
Rhino no longer caches generated classes and information about reflected Java classes in static objects. Instead such caches are stored in a top scope object and initialized by default during call to <tt>initStandardObjects</tt> of <tt>org.mozilla.javascript.Context</tt>. This can be overridden with explicit call to the <tt>associate</tt> method of <tt>org.mozilla.javascript.ClassCache</tt> if cache sharing is desired. The change allows to instantiate multiple Rhino runtime instances which would not interfere with each other and prevents memory leaks throw ever growing caches.  
</p>

<h3>API for compiling scripts into class files</h3>
<p>The new class <tt>org.mozilla.javascript.optimizer.ClassCompiler</tt> provides a simple API to compile JavaScript source into set of Java class files with the given set of compilation options. <a href="jsc.html">JavaScript Compiler</a> was upgraded to use new API and the old API were deprecated.
</p>

<h3>Optimizer generates only one class per script </h3>
<p>
In Rhino 1.5R5 the default optimization mode generates only one Java class for script and all its functions while previously the optimizer generated additional class for each function definition in the script. It improves loading time for scripts and decreases memory usage especially for scripts with many function definitions. 
</p>
<p>
See <a href="http://bugzilla.mozilla.org/show_bug.cgi?id=198086">Bugzilla 198086</a>.
</p>

<h3>Improved support for huge scripts</h3>
<p>
The interpreted mode contains significantly less restrictions on size and complexity of the scripts and if the remaining restrictions are not satisfied, Rhino will report an exception instead of generating corrupted internal byte code for interpreting.
</p>
<p>
See <a href="http://bugzilla.mozilla.org/show_bug.cgi?id=225831">Bugzilla 225831</a>.
</p>

<h2>Resolved Bugzilla reports</h2>
<p>
The full list of Bugzilla reports addressed in Rhino 1.5R5 can be obtained with the following Bugzilla query:
<br>
<a href="http://bugzilla.mozilla.org/buglist.cgi?product=Rhino&target_milestone=1.5R5&bug_status=RESOLVED&bug_status=VERIFIED">http://bugzilla.mozilla.org/buglist.cgi?product=Rhino&amp;target_milestone=1.5R5&amp;bug_status=RESOLVED&amp;bug_status=VERIFIED</a>
<br>
which searches <a href="http://bugzilla.mozilla.org/">bugzilla.mozilla.org</a> for all resolved or verified bugs with the product set to Rhino and the target milestone set to 1.5R5.
</p>

<hr width="100%"><br>
<a href="index.html">back to top</a></h3>

</body></html>
